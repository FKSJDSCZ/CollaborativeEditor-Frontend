{"version":3,"sources":["../src/client/provider.ts"],"sourcesContent":["import * as Y from 'yjs'\r\nimport * as bc from 'lib0/broadcastchannel'\r\nimport * as AwarenessProtocol from 'y-protocols/awareness'\r\nimport {Observable} from 'lib0/observable'\r\nimport {io, ManagerOptions, Socket, SocketOptions} from 'socket.io-client'\r\nimport {AwarenessChange} from '../types'\r\n\r\n/**\r\n * SocketIOProvider instance configuration. Here you can configure:\r\n * - autoConnect: (Optional) Will try to connect to the server when the instance is created if true; otherwise you have to call `provider.connect()` manually\r\n * - awareness: (Optional) Give an existing awareness\r\n * - resyncInterval: (Optional) Specify the number of milliseconds to set an interval to synchronize the document,\r\n *   if it is greater than 0 enable the synchronization interval (by default is -1)\r\n * - disableBc: (Optional) This boolean disable the broadcast channel functionality, by default is false (broadcast channel enabled)\r\n * - onConnect: (Optional) Set a callback that will triggered immediately when the socket is connected\r\n * - onDisconnect: (Optional) Set a callback that will triggered immediately when the socket is disconnected\r\n * - onConnectError: (Optional) Set a callback that will triggered immediately when the occurs a socket connection error\r\n */\r\nexport interface ProviderConfiguration {\r\n\t/**\r\n\t * (Optional) This boolean specify if the provider should connect when the instance is created, by default is true\r\n\t */\r\n\tautoConnect?: boolean\r\n\t/**\r\n\t * (Optional) An existent awareness, by default is a new AwarenessProtocol.Awareness instance\r\n\t */\r\n\tawareness?: AwarenessProtocol.Awareness\r\n\t/**\r\n\t * (optional) Specify the number of milliseconds to synchronize, by default is -1 (this disable resync interval)\r\n\t */\r\n\tresyncInterval?: number\r\n\t/**\r\n\t * (Optional) This boolean disable the broadcast channel functionality, by default is false (broadcast channel enabled)\r\n\t */\r\n\tdisableBc?: boolean\r\n\t/**\r\n\t * (Optional) Add the authentication data\r\n\t */\r\n\tauth?: { [key: string]: any }\r\n}\r\n\r\n/**\r\n * The socket io provider class to sync a document\r\n */\r\nexport class SocketIOProvider extends Observable<string> {\r\n\t/**\r\n\t * The connection url to server. Example: `ws://localhost:3001`\r\n\t * @type {string}\r\n\t */\r\n\tprivate readonly _url: string\r\n\t/**\r\n\t * The name of the document room\r\n\t * @type {string}\r\n\t */\r\n\tpublic roomName: string\r\n\t/**\r\n\t * The broadcast channel room\r\n\t * @type {string}\r\n\t * @private\r\n\t */\r\n\tprivate readonly _broadcastChannel: string\r\n\t/**\r\n\t * The socket connection\r\n\t * @type {Socket}\r\n\t */\r\n\tpublic socket: Socket\r\n\t/**\r\n\t * The yjs document\r\n\t * @type {Y.Doc}\r\n\t */\r\n\tpublic doc: Y.Doc\r\n\t/**\r\n\t * The awareness\r\n\t * @type {AwarenessProtocol.Awareness}\r\n\t */\r\n\tpublic awareness: AwarenessProtocol.Awareness\r\n\t/**\r\n\t * Disable broadcast channel, by default is false\r\n\t * @type {boolean}\r\n\t */\r\n\tpublic disableBc: boolean\r\n\t/**\r\n\t * The broadcast channel connection status indicator\r\n\t * @type {boolean}\r\n\t */\r\n\tpublic bcconnected: boolean = false\r\n\t/**\r\n\t * The document's sync status indicator\r\n\t * @type {boolean}\r\n\t * @private\r\n\t */\r\n\tprivate _synced: boolean = false\r\n\t/**\r\n\t * Interval to emit `sync-step-1` to sync changes\r\n\t * @type {ReturnType<typeof setTimeout> | null}\r\n\t * @private\r\n\t */\r\n\tprivate resyncInterval: ReturnType<typeof setTimeout> | null = null\r\n\t/**\r\n\t * Optional overrides for socket.io\r\n\t * @type {Partial<ManagerOptions & SocketOptions> | undefined}\r\n\t * @private\r\n\t */\r\n\tprivate readonly _socketIoOptions: Partial<ManagerOptions & SocketOptions> | undefined;\r\n\r\n\t/**\r\n\t * SocketIOProvider constructor\r\n\t * @constructor\r\n\t * @param {string} url The connection url from server\r\n\t * @param {string} roomName The document's room name\r\n\t * @param {Y.Doc} doc The yjs document\r\n\t * @param {ProviderConfiguration} options Configuration options to the SocketIOProvider\r\n\t * @param {Partial<ManagerOptions & SocketOptions> | undefined} socketIoOptions optional overrides for socket.io\r\n\t */\r\n\tconstructor(url: string, roomName: string, doc: Y.Doc = new Y.Doc(), {\r\n\t\t            autoConnect = true,\r\n\t\t            awareness = new AwarenessProtocol.Awareness(doc),\r\n\t\t            resyncInterval = -1,\r\n\t\t            disableBc = false,\r\n\t\t            auth = {}\r\n\t            }: ProviderConfiguration,\r\n\t            socketIoOptions: Partial<ManagerOptions & SocketOptions> | undefined = undefined) {\r\n\t\tsuper()\r\n\t\twhile (url[url.length - 1] === '/') {\r\n\t\t\turl = url.slice(0, url.length - 1)\r\n\t\t}\r\n\t\tthis._url = url\r\n\t\tthis.roomName = roomName\r\n\t\tthis.doc = doc\r\n\t\tthis.awareness = awareness\r\n\r\n\t\tthis._broadcastChannel = `${url}/${roomName}`\r\n\t\tthis.disableBc = disableBc\r\n\t\tthis._socketIoOptions = socketIoOptions;\r\n\r\n\t\tthis.socket = io(this.url, {\r\n\t\t\tautoConnect: false,\r\n\t\t\ttransports: ['websocket'],\r\n\t\t\tforceNew: true,\r\n\t\t\tauth: auth,\r\n\t\t\t...socketIoOptions\r\n\t\t})\r\n\r\n\t\tthis.doc.on('update', this.onUpdateDoc)\r\n\r\n\t\tthis.socket.on('connect', () => {\r\n\t\t\tthis.emit('status', [{status: 'connecting'}])\r\n\t\t\tthis.socket.emit('join-room', roomName, auth, (success: boolean) => {\r\n\t\t\t\tif (success) {\r\n\t\t\t\t\tthis.onSocketConnection(resyncInterval)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.emit('error', [{message: 'Failed to join room'}])\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\r\n\t\tthis.socket.on('disconnect', (event) => this.onSocketDisconnection(event))\r\n\r\n\t\tthis.socket.on('connect_error', (error) => this.onSocketConnectionError(error))\r\n\r\n\t\tthis.initSyncListeners()\r\n\r\n\t\tthis.initAwarenessListeners()\r\n\r\n\t\tthis.initSystemListeners()\r\n\r\n\t\tawareness.on('update', this.awarenessUpdate)\r\n\r\n\t\tif (autoConnect) this.connect()\r\n\t}\r\n\r\n\t/**\r\n\t * Broadcast channel room getter\r\n\t * @type {string}\r\n\t */\r\n\tpublic get broadcastChannel(): string {\r\n\t\treturn this._broadcastChannel\r\n\t}\r\n\r\n\t/**\r\n\t * URL getter\r\n\t * @type {string}\r\n\t */\r\n\tpublic get url(): string {\r\n\t\treturn this._url\r\n\t}\r\n\r\n\t/**\r\n\t * Synchronized state flag getter\r\n\t * @type {boolean}\r\n\t */\r\n\tpublic get synced(): boolean {\r\n\t\treturn this._synced\r\n\t}\r\n\r\n\t/**\r\n\t * Synchronized state flag setter\r\n\t */\r\n\tpublic set synced(state) {\r\n\t\tif (this._synced !== state) {\r\n\t\t\tthis._synced = state\r\n\t\t\tthis.emit('synced', [state])\r\n\t\t\tthis.emit('sync', [state])\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This function initializes the socket event listeners to synchronize document changes.\r\n\t *\r\n\t *  The synchronization protocol is as follows:\r\n\t *  - A server emits the sync step one event (`sync-step-1`) which sends the document as a state vector\r\n\t *    and the sync step two callback as an acknowledgment according to the socket io acknowledgments.\r\n\t *  - When the client receives the `sync-step-1` event, it executes the `syncStep2` acknowledgment callback and sends\r\n\t *    the difference between the received state vector and the local document (this difference is called an update).\r\n\t *  - The second step of the sync is to apply the update sent in the `syncStep2` callback parameters from the client\r\n\t *    to the document on the server side.\r\n\t *  - There is another event (`sync-update`) that is emitted from the server, which sends an update for the document,\r\n\t *    and when the client receives this event, it applies the received update to the local document.\r\n\t *  - When an update is applied to a document, it will fire the document's \"update\" event, which\r\n\t *    sends the update to the server.\r\n\t * @type {() => void}\r\n\t * @private\r\n\t */\r\n\tprivate readonly initSyncListeners = (): void => {\r\n\t\tthis.socket.on('sync-step-1', (stateVector: ArrayBuffer, syncStep2: (update: Uint8Array) => void) => {\r\n\t\t\tsyncStep2(Y.encodeStateAsUpdate(this.doc, new Uint8Array(stateVector)))\r\n\t\t\tthis.synced = true\r\n\t\t})\r\n\r\n\t\tthis.socket.on('sync-update', this.onSocketSyncUpdate)\r\n\t}\r\n\r\n\t/**\r\n\t * This function initializes socket event listeners to synchronize awareness changes.\r\n\t *\r\n\t *  The awareness protocol is as follows:\r\n\t *  - The server emits the `awareness-update` event by sending the awareness update.\r\n\t *  - The client receives that event and applies the received update to the local awareness.\r\n\t *  - When an update is applied to awareness, the awareness \"update\" event will fire, which\r\n\t *    sends the update to the server.\r\n\t * @type {() => void}\r\n\t * @private\r\n\t */\r\n\tprivate readonly initAwarenessListeners = (): void => {\r\n\t\tthis.socket.on('awareness-update', (update: ArrayBuffer) => {\r\n\t\t\tAwarenessProtocol.applyAwarenessUpdate(this.awareness, new Uint8Array(update), this)\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * This function initialize the window or process events listener. Specifically set ups the\r\n\t * window `beforeunload` and process `exit` events to remove the client from the awareness.\r\n\t * @type {() => void}\r\n\t */\r\n\tprivate readonly initSystemListeners = (): void => {\r\n\t\tif (typeof window !== 'undefined') window.addEventListener('beforeunload', this.beforeUnloadHandler)\r\n\t\telse if (typeof process !== 'undefined') process.on('exit', this.beforeUnloadHandler)\r\n\t}\r\n\r\n\t/**\r\n\t * Connect provider's socket\r\n\t * @type {() => void}\r\n\t */\r\n\tpublic connect(): void {\r\n\t\tif (!this.socket.connected) {\r\n\t\t\tthis.emit('status', [{status: 'connecting'}])\r\n\t\t\tthis.socket.connect()\r\n\t\t\tif (!this.disableBc) this.connectBc()\r\n\t\t\tthis.synced = false\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This function runs when the socket connects and reconnects and emits the `sync-step-1`\r\n\t * and `awareness-update` socket events to start synchronization.\r\n\t *\r\n\t *  Also starts the resync interval if is enabled.\r\n\t * @private\r\n\t * @param {() => void | Promise<void>} onConnect (Optional) A callback that will be triggered every time that socket is connected or reconnected\r\n\t * @param {number} resyncInterval (Optional) A number of milliseconds for interval of synchronize\r\n\t * @type {(onConnect: () => void | Promise<void>, resyncInterval: number = -1) => void}\r\n\t */\r\n\tprivate readonly onSocketConnection = (resyncInterval: ProviderConfiguration['resyncInterval'] = -1): void => {\r\n\t\tthis.emit('status', [{status: 'connected'}])\r\n\t\tthis.socket.emit('sync-step-1', Y.encodeStateVector(this.doc), (update: Uint8Array) => {\r\n\t\t\tY.applyUpdate(this.doc, new Uint8Array(update), this)\r\n\t\t})\r\n\t\tif (this.awareness.getLocalState() !== null) this.socket.emit('awareness-update', AwarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\r\n\t\tif (resyncInterval > 0) {\r\n\t\t\tthis.resyncInterval = setInterval(() => {\r\n\t\t\t\tif (this.socket.disconnected) return\r\n\t\t\t\tthis.socket.emit('sync-step-1', Y.encodeStateVector(this.doc), (update: Uint8Array) => {\r\n\t\t\t\t\tY.applyUpdate(this.doc, new Uint8Array(update), this)\r\n\t\t\t\t})\r\n\t\t\t}, resyncInterval)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Disconnect provider's socket\r\n\t * @type {() => void}\r\n\t */\r\n\tpublic disconnect(): void {\r\n\t\tif (this.socket.connected) {\r\n\t\t\tthis.disconnectBc()\r\n\t\t\tthis.socket.disconnect()\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This function runs when the socket is disconnected and emits the socket event `awareness-update`\r\n\t * which removes this client from awareness.\r\n\t * @private\r\n\t * @param {Socket.DisconnectReason} event The reason of the socket disconnection\r\n\t * @param {() => void | Promise<void>} onDisconnect (Optional) A callback that will be triggered every time that socket is disconnected\r\n\t * @type {(event: Socket.DisconnectReason, onDisconnect: () => void | Promise<void>) => void}\r\n\t */\r\n\tprivate readonly onSocketDisconnection = (event: Socket.DisconnectReason): void => {\r\n\t\tthis.emit('connection-close', [event, this])\r\n\t\tthis.synced = false\r\n\t\tAwarenessProtocol.removeAwarenessStates(this.awareness, Array.from(this.awareness.getStates().keys()).filter(client => client !== this.doc.clientID), this)\r\n\t\tthis.emit('status', [{status: 'disconnected'}])\r\n\t}\r\n\r\n\t/**\r\n\t * This function is executed when the socket connection fails.\r\n\t * @param {Error} error The error in the connection\r\n\t * @param {(error: Error) => void | Promise<void>} onConnectError (Optional) A callback that will be triggered every time that socket has a connection error\r\n\t * @type {(error: Error, onConnectError: (error: Error) => void | Promise<void>) => void}\r\n\t */\r\n\tprivate readonly onSocketConnectionError = (error: Error): void => {\r\n\t\tthis.emit('connection-error', [error, this])\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy the provider. This method clears the document, awareness, and window/process listeners and disconnects the socket.\r\n\t * @type {() => void}\r\n\t */\r\n\tpublic destroy(): void {\r\n\t\tif (this.resyncInterval != null) clearInterval(this.resyncInterval)\r\n\t\tthis.disconnect()\r\n\t\tif (typeof window !== 'undefined') window.removeEventListener('beforeunload', this.beforeUnloadHandler)\r\n\t\telse if (typeof process !== 'undefined') process.off('exit', this.beforeUnloadHandler)\r\n\t\tthis.awareness.off('update', this.awarenessUpdate)\r\n\t\tthis.awareness.destroy();\r\n\t\tthis.doc.off('update', this.onUpdateDoc)\r\n\t\tsuper.destroy()\r\n\t}\r\n\r\n\t/**\r\n\t * This function is executed when the document is updated, if the instance that\r\n\t * emit the change is not this, it emit the changes by socket and broadcast channel.\r\n\t * @private\r\n\t * @param {Uint8Array} update Document update\r\n\t * @param {SocketIOProvider} origin The SocketIOProvider instance that emits the change.\r\n\t * @type {(update: Uint8Array, origin: SocketIOProvider) => void}\r\n\t */\r\n\tprivate readonly onUpdateDoc = (update: Uint8Array, origin: SocketIOProvider): void => {\r\n\t\tif (origin !== this) {\r\n\t\t\tthis.socket.emit('sync-update', update)\r\n\t\t\tif (this.bcconnected) {\r\n\t\t\t\tbc.publish(this._broadcastChannel, {\r\n\t\t\t\t\ttype: 'sync-update',\r\n\t\t\t\t\tdata: update\r\n\t\t\t\t}, this)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This function is called when the server emits the `sync-update` event and applies the received update to the local document.\r\n\t * @private\r\n\t * @param {Uint8Array}update A document update received by the `sync-update` socket event\r\n\t * @type {(update: Uint8Array) => void}\r\n\t */\r\n\tprivate readonly onSocketSyncUpdate = (update: ArrayBuffer): void => {\r\n\t\tY.applyUpdate(this.doc, new Uint8Array(update), this)\r\n\t}\r\n\r\n\t/**\r\n\t * This function is executed when the local awareness changes and this broadcasts the changes per socket and broadcast channel.\r\n\t * @private\r\n\t * @param {{ added: number[], updated: number[], removed: number[] }} awarenessChanges The clients added, updated and removed\r\n\t * @param {SocketIOProvider | null} origin The SocketIOProvider instance that emits the change.\r\n\t * @type {({ added, updated, removed }: { added: number[], updated: number[], removed: number[] }, origin: SocketIOProvider | null) => void}\r\n\t */\r\n\tprivate readonly awarenessUpdate = ({added, updated, removed}: AwarenessChange, origin: SocketIOProvider | null): void => {\r\n\t\tconst changedClients = added.concat(updated).concat(removed)\r\n\t\tthis.socket.emit('awareness-update', AwarenessProtocol.encodeAwarenessUpdate(this.awareness, changedClients))\r\n\t\tif (this.bcconnected) {\r\n\t\t\tbc.publish(this._broadcastChannel, {\r\n\t\t\t\ttype: 'awareness-update',\r\n\t\t\t\tdata: AwarenessProtocol.encodeAwarenessUpdate(this.awareness, changedClients)\r\n\t\t\t}, this)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This function is executed when the windows will be unloaded or the process will be closed and this\r\n\t * will remove the local client from awareness.\r\n\t * @private\r\n\t * @type {() => void}\r\n\t */\r\n\tprivate readonly beforeUnloadHandler = (): void => {\r\n\t\tAwarenessProtocol.removeAwarenessStates(this.awareness, [this.doc.clientID], 'window unload')\r\n\t}\r\n\r\n\t/**\r\n\t * This function subscribes the provider to the broadcast channel and initiates synchronization by broadcast channel.\r\n\t * @type {() => void}\r\n\t */\r\n\tprivate readonly connectBc = (): void => {\r\n\t\tif (!this.bcconnected) {\r\n\t\t\tbc.subscribe(this._broadcastChannel, this.onBroadcastChannelMessage)\r\n\t\t\tthis.bcconnected = true\r\n\t\t}\r\n\t\tbc.publish(this._broadcastChannel, {type: 'sync-step-1', data: Y.encodeStateVector(this.doc)}, this)\r\n\t\tbc.publish(this._broadcastChannel, {type: 'sync-step-2', data: Y.encodeStateAsUpdate(this.doc)}, this)\r\n\t\tbc.publish(this._broadcastChannel, {type: 'query-awareness', data: null}, this)\r\n\t\tbc.publish(this._broadcastChannel, {type: 'awareness-update', data: AwarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID])}, this)\r\n\t}\r\n\r\n\t/**\r\n\t * This function unsubscribes the provider from the broadcast channel and before unsubscribing, updates the awareness.\r\n\t * @type {() => void}\r\n\t */\r\n\tprivate readonly disconnectBc = (): void => {\r\n\t\tbc.publish(this._broadcastChannel, {\r\n\t\t\ttype: 'awareness-update',\r\n\t\t\tdata: AwarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map())\r\n\t\t}, this)\r\n\t\tif (this.bcconnected) {\r\n\t\t\tbc.unsubscribe(this._broadcastChannel, this.onBroadcastChannelMessage)\r\n\t\t\tthis.bcconnected = false\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method handles messages received by the broadcast channel and responds to them.\r\n\t * @param {{ type: string, data: any }} message The object message received by broadcast channel\r\n\t * @param {SocketIOProvider} origin The SocketIOProvider instance that emits the change\r\n\t * @type {(message: { type: string, data: any }, origin: SocketIOProvider) => void}\r\n\t */\r\n\tprivate readonly onBroadcastChannelMessage = (message: { type: string, data: any }, origin: SocketIOProvider): void => {\r\n\t\tif (origin !== this && message.type.length > 0) {\r\n\t\t\tswitch (message.type) {\r\n\t\t\t\tcase 'sync-step-1':\r\n\t\t\t\t\tbc.publish(this._broadcastChannel, {\r\n\t\t\t\t\t\ttype: 'sync-step-2',\r\n\t\t\t\t\t\tdata: Y.encodeStateAsUpdate(this.doc, message.data)\r\n\t\t\t\t\t}, this)\r\n\t\t\t\t\tbreak\r\n\r\n\t\t\t\tcase 'sync-step-2':\r\n\t\t\t\t\tY.applyUpdate(this.doc, new Uint8Array(message.data), this)\r\n\t\t\t\t\tbreak\r\n\r\n\t\t\t\tcase 'sync-update':\r\n\t\t\t\t\tY.applyUpdate(this.doc, new Uint8Array(message.data), this)\r\n\t\t\t\t\tbreak\r\n\r\n\t\t\t\tcase 'query-awareness':\r\n\t\t\t\t\tbc.publish(this._broadcastChannel, {\r\n\t\t\t\t\t\ttype: 'awareness-update',\r\n\t\t\t\t\t\tdata: AwarenessProtocol.encodeAwarenessUpdate(this.awareness, Array.from(this.awareness.getStates().keys()))\r\n\t\t\t\t\t}, this)\r\n\t\t\t\t\tbreak\r\n\r\n\t\t\t\tcase 'awareness-update':\r\n\t\t\t\t\tAwarenessProtocol.applyAwarenessUpdate(this.awareness, new Uint8Array(message.data), this)\r\n\t\t\t\t\tbreak\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"],"mappings":";AAAA,YAAYA,OAAO;AACnB,YAAYC,OAAQ;AACpB,YAAYC,OAAuB;AACnC,SAAQ,cAAAC,SAAiB;AACzB,SAAQ,MAAAC,SAAgD;AAwCjD,IAAMC,IAAN,cAA+BF,EAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsExD,YAAYG,GAAaC,GAAkBC,IAAa,IAAM,MAAI,GAAG;AAAA,IACxD,aAAAC,IAAc;AAAA,IACd,WAAAC,IAAY,IAAsB,YAAUF,CAAG;AAAA,IAC/C,gBAAAG,IAAiB;AAAA,IACjB,WAAAC,IAAY;AAAA,IACZ,MAAAC,IAAO,CAAC;AAAA,EACT,GACAC,IAAuE,QAAW;AAC7F,UAAM;AArCP;AAAA;AAAA;AAAA;AAAA,SAAO,cAAuB;AAM9B;AAAA;AAAA;AAAA;AAAA;AAAA,SAAQ,UAAmB;AAM3B;AAAA;AAAA;AAAA;AAAA;AAAA,SAAQ,iBAAuD;AA8H/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,oBAAoB,MAAY;AAChD,WAAK,OAAO,GAAG,eAAe,CAACC,GAA0BC,MAA4C;AACpG,QAAAA,EAAY,sBAAoB,KAAK,KAAK,IAAI,WAAWD,CAAW,CAAC,CAAC,GACtE,KAAK,SAAS;AAAA,MACf,CAAC,GAED,KAAK,OAAO,GAAG,eAAe,KAAK,kBAAkB;AAAA,IACtD;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,yBAAyB,MAAY;AACrD,WAAK,OAAO,GAAG,oBAAoB,CAACE,MAAwB;AAC3D,QAAkB,uBAAqB,KAAK,WAAW,IAAI,WAAWA,CAAM,GAAG,IAAI;AAAA,MACpF,CAAC;AAAA,IACF;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,sBAAsB,MAAY;AAClD,MAAI,OAAO,UAAW,cAAa,OAAO,iBAAiB,gBAAgB,KAAK,mBAAmB,IAC1F,OAAO,WAAY,eAAa,QAAQ,GAAG,QAAQ,KAAK,mBAAmB;AAAA,IACrF;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,qBAAqB,CAACN,IAA0D,OAAa;AAC7G,WAAK,KAAK,UAAU,CAAC,EAAC,QAAQ,YAAW,CAAC,CAAC,GAC3C,KAAK,OAAO,KAAK,eAAiB,oBAAkB,KAAK,GAAG,GAAG,CAACM,MAAuB;AACtF,QAAE,cAAY,KAAK,KAAK,IAAI,WAAWA,CAAM,GAAG,IAAI;AAAA,MACrD,CAAC,GACG,KAAK,UAAU,cAAc,MAAM,QAAM,KAAK,OAAO,KAAK,oBAAsC,wBAAsB,KAAK,WAAW,CAAC,KAAK,IAAI,QAAQ,CAAC,CAAC,GAC1JN,IAAiB,MACpB,KAAK,iBAAiB,YAAY,MAAM;AACvC,QAAI,KAAK,OAAO,gBAChB,KAAK,OAAO,KAAK,eAAiB,oBAAkB,KAAK,GAAG,GAAG,CAACM,MAAuB;AACtF,UAAE,cAAY,KAAK,KAAK,IAAI,WAAWA,CAAM,GAAG,IAAI;AAAA,QACrD,CAAC;AAAA,MACF,GAAGN,CAAc;AAAA,IAEnB;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,wBAAwB,CAACO,MAAyC;AAClF,WAAK,KAAK,oBAAoB,CAACA,GAAO,IAAI,CAAC,GAC3C,KAAK,SAAS,IACI,wBAAsB,KAAK,WAAW,MAAM,KAAK,KAAK,UAAU,UAAU,EAAE,KAAK,CAAC,EAAE,OAAO,CAAAC,MAAUA,MAAW,KAAK,IAAI,QAAQ,GAAG,IAAI,GAC1J,KAAK,KAAK,UAAU,CAAC,EAAC,QAAQ,eAAc,CAAC,CAAC;AAAA,IAC/C;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,0BAA0B,CAACC,MAAuB;AAClE,WAAK,KAAK,oBAAoB,CAACA,GAAO,IAAI,CAAC;AAAA,IAC5C;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,cAAc,CAACH,GAAoBI,MAAmC;AACtF,MAAIA,MAAW,SACd,KAAK,OAAO,KAAK,eAAeJ,CAAM,GAClC,KAAK,eACL,UAAQ,KAAK,mBAAmB;AAAA,QAClC,MAAM;AAAA,QACN,MAAMA;AAAA,MACP,GAAG,IAAI;AAAA,IAGV;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,qBAAqB,CAACA,MAA8B;AACpE,MAAE,cAAY,KAAK,KAAK,IAAI,WAAWA,CAAM,GAAG,IAAI;AAAA,IACrD;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,kBAAkB,CAAC,EAAC,OAAAK,GAAO,SAAAC,GAAS,SAAAC,EAAO,GAAoBH,MAA0C;AACzH,UAAMI,IAAiBH,EAAM,OAAOC,CAAO,EAAE,OAAOC,CAAO;AAC3D,WAAK,OAAO,KAAK,oBAAsC,wBAAsB,KAAK,WAAWC,CAAc,CAAC,GACxG,KAAK,eACL,UAAQ,KAAK,mBAAmB;AAAA,QAClC,MAAM;AAAA,QACN,MAAwB,wBAAsB,KAAK,WAAWA,CAAc;AAAA,MAC7E,GAAG,IAAI;AAAA,IAET;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,sBAAsB,MAAY;AAClD,MAAkB,wBAAsB,KAAK,WAAW,CAAC,KAAK,IAAI,QAAQ,GAAG,eAAe;AAAA,IAC7F;AAMA;AAAA;AAAA;AAAA;AAAA,SAAiB,YAAY,MAAY;AACxC,MAAK,KAAK,gBACN,YAAU,KAAK,mBAAmB,KAAK,yBAAyB,GACnE,KAAK,cAAc,KAEjB,UAAQ,KAAK,mBAAmB,EAAC,MAAM,eAAe,MAAQ,oBAAkB,KAAK,GAAG,EAAC,GAAG,IAAI,GAChG,UAAQ,KAAK,mBAAmB,EAAC,MAAM,eAAe,MAAQ,sBAAoB,KAAK,GAAG,EAAC,GAAG,IAAI,GAClG,UAAQ,KAAK,mBAAmB,EAAC,MAAM,mBAAmB,MAAM,KAAI,GAAG,IAAI,GAC3E,UAAQ,KAAK,mBAAmB,EAAC,MAAM,oBAAoB,MAAwB,wBAAsB,KAAK,WAAW,CAAC,KAAK,IAAI,QAAQ,CAAC,EAAC,GAAG,IAAI;AAAA,IACxJ;AAMA;AAAA;AAAA;AAAA;AAAA,SAAiB,eAAe,MAAY;AAC3C,MAAG,UAAQ,KAAK,mBAAmB;AAAA,QAClC,MAAM;AAAA,QACN,MAAwB,wBAAsB,KAAK,WAAW,CAAC,KAAK,IAAI,QAAQ,GAAG,oBAAI,IAAI,CAAC;AAAA,MAC7F,GAAG,IAAI,GACH,KAAK,gBACL,cAAY,KAAK,mBAAmB,KAAK,yBAAyB,GACrE,KAAK,cAAc;AAAA,IAErB;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,4BAA4B,CAACC,GAAsCL,MAAmC;AACtH,UAAIA,MAAW,QAAQK,EAAQ,KAAK,SAAS;AAC5C,gBAAQA,EAAQ,MAAM;AAAA,UACrB,KAAK;AACJ,YAAG,UAAQ,KAAK,mBAAmB;AAAA,cAClC,MAAM;AAAA,cACN,MAAQ,sBAAoB,KAAK,KAAKA,EAAQ,IAAI;AAAA,YACnD,GAAG,IAAI;AACP;AAAA,UAED,KAAK;AACJ,YAAE,cAAY,KAAK,KAAK,IAAI,WAAWA,EAAQ,IAAI,GAAG,IAAI;AAC1D;AAAA,UAED,KAAK;AACJ,YAAE,cAAY,KAAK,KAAK,IAAI,WAAWA,EAAQ,IAAI,GAAG,IAAI;AAC1D;AAAA,UAED,KAAK;AACJ,YAAG,UAAQ,KAAK,mBAAmB;AAAA,cAClC,MAAM;AAAA,cACN,MAAwB,wBAAsB,KAAK,WAAW,MAAM,KAAK,KAAK,UAAU,UAAU,EAAE,KAAK,CAAC,CAAC;AAAA,YAC5G,GAAG,IAAI;AACP;AAAA,UAED,KAAK;AACJ,YAAkB,uBAAqB,KAAK,WAAW,IAAI,WAAWA,EAAQ,IAAI,GAAG,IAAI;AACzF;AAAA,UAED;AACC;AAAA,QACF;AAAA,IAEF;AA5dD,WA2HSpB,EAAIA,EAAI,SAAS,CAAC,MAAM;AAC9B,MAAAA,IAAMA,EAAI,MAAM,GAAGA,EAAI,SAAS,CAAC;AAElC,SAAK,OAAOA,GACZ,KAAK,WAAWC,GAChB,KAAK,MAAMC,GACX,KAAK,YAAYE,GAEjB,KAAK,oBAAoB,GAAGJ,KAAOC,KACnC,KAAK,YAAYK,GACjB,KAAK,mBAAmBE,GAExB,KAAK,SAASV,EAAG,KAAK,KAAK;AAAA,MAC1B,aAAa;AAAA,MACb,YAAY,CAAC,WAAW;AAAA,MACxB,UAAU;AAAA,MACV,MAAMS;AAAA,MACN,GAAGC;AAAA,IACJ,CAAC,GAED,KAAK,IAAI,GAAG,UAAU,KAAK,WAAW,GAEtC,KAAK,OAAO,GAAG,WAAW,MAAM;AAC/B,WAAK,KAAK,UAAU,CAAC,EAAC,QAAQ,aAAY,CAAC,CAAC,GAC5C,KAAK,OAAO,KAAK,aAAaP,GAAUM,GAAM,CAACc,MAAqB;AACnE,QAAIA,IACH,KAAK,mBAAmBhB,CAAc,IAEtC,KAAK,KAAK,SAAS,CAAC,EAAC,SAAS,sBAAqB,CAAC,CAAC;AAAA,MAEvD,CAAC;AAAA,IACF,CAAC,GAED,KAAK,OAAO,GAAG,cAAc,CAACO,MAAU,KAAK,sBAAsBA,CAAK,CAAC,GAEzE,KAAK,OAAO,GAAG,iBAAiB,CAACE,MAAU,KAAK,wBAAwBA,CAAK,CAAC,GAE9E,KAAK,kBAAkB,GAEvB,KAAK,uBAAuB,GAE5B,KAAK,oBAAoB,GAEzBV,EAAU,GAAG,UAAU,KAAK,eAAe,GAEvCD,KAAa,KAAK,QAAQ;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,mBAA2B;AACrC,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,MAAc;AACxB,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,SAAkB;AAC5B,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,OAAOmB,GAAO;AACxB,IAAI,KAAK,YAAYA,MACpB,KAAK,UAAUA,GACf,KAAK,KAAK,UAAU,CAACA,CAAK,CAAC,GAC3B,KAAK,KAAK,QAAQ,CAACA,CAAK,CAAC;AAAA,EAE3B;AAAA;AAAA;AAAA;AAAA;AAAA,EA2DO,UAAgB;AACtB,IAAK,KAAK,OAAO,cAChB,KAAK,KAAK,UAAU,CAAC,EAAC,QAAQ,aAAY,CAAC,CAAC,GAC5C,KAAK,OAAO,QAAQ,GACf,KAAK,aAAW,KAAK,UAAU,GACpC,KAAK,SAAS;AAAA,EAEhB;AAAA;AAAA;AAAA;AAAA;AAAA,EAgCO,aAAmB;AACzB,IAAI,KAAK,OAAO,cACf,KAAK,aAAa,GAClB,KAAK,OAAO,WAAW;AAAA,EAEzB;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BO,UAAgB;AACtB,IAAI,KAAK,kBAAkB,QAAM,cAAc,KAAK,cAAc,GAClE,KAAK,WAAW,GACZ,OAAO,UAAW,cAAa,OAAO,oBAAoB,gBAAgB,KAAK,mBAAmB,IAC7F,OAAO,WAAY,eAAa,QAAQ,IAAI,QAAQ,KAAK,mBAAmB,GACrF,KAAK,UAAU,IAAI,UAAU,KAAK,eAAe,GACjD,KAAK,UAAU,QAAQ,GACvB,KAAK,IAAI,IAAI,UAAU,KAAK,WAAW,GACvC,MAAM,QAAQ;AAAA,EACf;AAkID;","names":["Y","bc","AwarenessProtocol","Observable","io","SocketIOProvider","url","roomName","doc","autoConnect","awareness","resyncInterval","disableBc","auth","socketIoOptions","stateVector","syncStep2","update","event","client","error","origin","added","updated","removed","changedClients","message","success","state"]}